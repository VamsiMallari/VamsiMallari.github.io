<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Puzzles Hub</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, collection, addDoc, getDocs, doc, updateDoc, deleteDoc, setDoc, onSnapshot, query, where, orderBy, getDoc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut, updateProfile } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCuSurKpIMGQv8-yu4txJE_8_KZk5lSJ3w",
            authDomain: "chess-puzzels-rkv.firebaseapp.com",
            projectId: "chess-puzzels-rkv",
            storageBucket: "chess-puzzels-rkv.firebasestorage.app",
            messagingSenderId: "130806565295",
            appId: "1:130806565295:web:6f09088b2072e815ecc75a",
            measurementId: "G-87H1RF04D7"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        
        // Make Firebase available globally
        window.db = db;
        window.auth = auth;
        window.firestore = { collection, addDoc, getDocs, doc, updateDoc, deleteDoc, setDoc, onSnapshot, query, where, orderBy, getDoc };
        window.firebaseAuth = { createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut, updateProfile };
        
        // Initialize the app after Firebase is ready
        window.initializeChessApp();
    </script>
    <style>
        .chess-square {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            cursor: pointer;
            user-select: none;
            border: 1px solid #333;
        }
        .light-square { background-color: #f0d9b5; }
        .dark-square { background-color: #b58863; }
        .chess-board-container {
            display: inline-block;
            position: relative;
        }
        .rank-label, .file-label {
            font-weight: bold;
            font-size: 14px;
            color: #333;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .rank-label {
            width: 20px;
            height: 60px;
        }
        .file-label {
            width: 60px;
            height: 20px;
        }
        .selected { box-shadow: inset 0 0 0 3px #ff6b6b; }
        .possible-move { 
            position: relative;
        }
        .possible-move::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            background-color: rgba(0, 255, 0, 0.6);
            border-radius: 50%;
        }
        .piece-bank {
            display: flex;
            gap: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 8px;
            margin: 10px 0;
        }
        .piece-bank-item {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            cursor: pointer;
            border: 2px solid #ddd;
            border-radius: 4px;
            background-color: white;
        }
        .piece-bank-item:hover {
            border-color: #007bff;
        }
        .king-in-check {
            box-shadow: inset 0 0 0 3px #ff0000 !important;
            animation: pulse-red 1s infinite;
        }
        @keyframes pulse-red {
            0% { box-shadow: inset 0 0 0 3px #ff0000; }
            50% { box-shadow: inset 0 0 0 5px #ff0000; }
            100% { box-shadow: inset 0 0 0 3px #ff0000; }
        }
        .results-modal {
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen">
    <div id="loadingOverlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white p-8 rounded-lg shadow-xl text-center">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
            <h3 class="text-lg font-semibold text-gray-800">Loading Chess Puzzles Hub...</h3>
            <p class="text-gray-600 mt-2">Connecting to cloud database</p>
        </div>
    </div>
    <div id="authModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-8 rounded-lg shadow-xl max-w-md w-full mx-4">
            <div id="loginForm">
                <h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">Login</h2>
                <div class="mb-4">
                    <label class="block text-gray-700 text-sm font-bold mb-2">Email:</label>
                    <input type="email" id="loginEmail" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500" placeholder="your@email.com">
                </div>
                <div class="mb-4">
                    <label class="block text-gray-700 text-sm font-bold mb-2">Password:</label>
                    <input type="password" id="loginPassword" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500" placeholder="Your password">
                </div>
                <div id="loginError" class="text-red-500 text-sm mb-4 hidden"></div>
                <button onclick="loginUser()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Login</button>
                <p class="text-center text-sm text-gray-600 mt-4">
                    Don't have an account? <button onclick="toggleAuthForm()" class="text-blue-600 hover:underline">Register here</button>
                </p>
            </div>
            <div id="registerForm" class="hidden">
                <h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">Register</h2>
                <div class="mb-4">
                    <label class="block text-gray-700 text-sm font-bold mb-2">Username:</label>
                    <input type="text" id="registerUsername" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500" placeholder="Choose a username">
                </div>
                <div class="mb-4">
                    <label class="block text-gray-700 text-sm font-bold mb-2">Email:</label>
                    <input type="email" id="registerEmail" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500" placeholder="your@email.com">
                </div>
                <div class="mb-4">
                    <label class="block text-gray-700 text-sm font-bold mb-2">Password:</label>
                    <input type="password" id="registerPassword" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500" placeholder="Create a password">
                </div>
                <div id="registerError" class="text-red-500 text-sm mb-4 hidden"></div>
                <button onclick="registerUser()" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Register</button>
                <p class="text-center text-sm text-gray-600 mt-4">
                    Already have an account? <button onclick="toggleAuthForm()" class="text-blue-600 hover:underline">Login here</button>
                </p>
            </div>
        </div>
    </div>


    <nav class="bg-white shadow-lg">
        <div class="max-w-7xl mx-auto px-4">
            <div class="flex justify-between items-center py-4">
                <h1 class="text-2xl font-bold text-gray-800">Chess Puzzles Hub</h1>
                <div class="flex space-x-4">
                    <button onclick="showSection('create')" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg transition duration-200">Create Puzzle</button>
                    <button onclick="showSection('puzzles')" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition duration-200">View Puzzles</button>
                    <button onclick="showSection('results')" class="bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-lg transition duration-200">Results</button>
                </div>
                <div id="userInfo" class="hidden items-center">
                    <span class="text-gray-600">Welcome, <span id="currentUser" class="font-semibold"></span></span>
                    <button onclick="logoutUser()" class="ml-4 bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded-lg text-sm">Logout</button>
                </div>
            </div>
        </div>
    </nav>

    <div id="createSection" class="max-w-6xl mx-auto p-6 hidden">
        <h2 class="text-3xl font-bold text-gray-800 mb-6">Create New Puzzle</h2>
        <div class="bg-white rounded-lg shadow-lg p-6">
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <div>
                    <div class="mb-4">
                        <label class="block text-gray-700 text-sm font-bold mb-2">Puzzle Title:</label>
                        <input type="text" id="puzzleTitle" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500" placeholder="Enter puzzle title">
                    </div>
                    <div class="mb-4">
                        <label class="block text-gray-700 text-sm font-bold mb-2">Description:</label>
                        <textarea id="puzzleDescription" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500 h-24" placeholder="Describe the puzzle objective"></textarea>
                    </div>
                    <div class="mb-4">
                        <label class="block text-gray-700 text-sm font-bold mb-2">First Move:</label>
                        <select id="firstMove" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500">
                            <option value="white">White to move</option>
                            <option value="black">Black to move</option>
                        </select>
                    </div>
                    <div class="flex space-x-4">
                        <button onclick="saveWithSolution()" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg transition duration-200">Save with Solution</button>
                        <button onclick="saveWithoutSolution()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg transition duration-200">Save without Solution</button>
                        <button onclick="clearBoard()" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg transition duration-200">Clear Board</button>
                    </div>
                </div>
                <div>
                    <h3 class="text-lg font-semibold mb-4">Setup Chess Board</h3>
                    
                    <div class="mb-4">
                        <h4 class="text-sm font-semibold mb-2">Black Pieces:</h4>
                        <div class="piece-bank">
                            <div class="piece-bank-item" onclick="selectPieceFromBank('♛')">♛</div>
                            <div class="piece-bank-item" onclick="selectPieceFromBank('♜')">♜</div>
                            <div class="piece-bank-item" onclick="selectPieceFromBank('♝')">♝</div>
                            <div class="piece-bank-item" onclick="selectPieceFromBank('♞')">♞</div>
                            <div class="piece-bank-item" onclick="selectPieceFromBank('♟')">♟</div>
                            <div class="piece-bank-item" onclick="selectPieceFromBank('♚')">♚</div>
                        </div>
                    </div>

                    <div class="chess-board-container mb-4">
                        <div id="createBoard"></div>
                    </div>

                    <div class="mb-4">
                        <h4 class="text-sm font-semibold mb-2">White Pieces:</h4>
                        <div class="piece-bank">
                            <div class="piece-bank-item" onclick="selectPieceFromBank('♕')">♕</div>
                            <div class="piece-bank-item" onclick="selectPieceFromBank('♖')">♖</div>
                            <div class="piece-bank-item" onclick="selectPieceFromBank('♗')">♗</div>
                            <div class="piece-bank-item" onclick="selectPieceFromBank('♘')">♘</div>
                            <div class="piece-bank-item" onclick="selectPieceFromBank('♙')">♙</div>
                            <div class="piece-bank-item" onclick="selectPieceFromBank('♔')">♔</div>
                            <div class="piece-bank-item" onclick="selectPieceFromBank('❌')" style="color: red;">❌</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="puzzlesSection" class="max-w-6xl mx-auto p-6">
        <h2 class="text-3xl font-bold text-gray-800 mb-6">Today's Puzzle</h2>
        <div id="todayPuzzle" class="space-y-6 mb-8"></div>

        <h2 class="text-3xl font-bold text-gray-800 mb-4">Archived Puzzles</h2>
        <div id="archivedPuzzlesContainer" class="bg-white rounded-lg shadow-lg p-4">
            <button onclick="toggleArchivedPuzzles()" class="w-full flex justify-between items-center text-left text-lg font-semibold py-2">
                <span>View Archived Puzzles</span>
                <svg id="archiveArrow" class="w-5 h-5 text-gray-400 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
            <div id="archivedPuzzles" class="hidden space-y-6 mt-4"></div>
        </div>
    </div>

    <div id="resultsSection" class="max-w-6xl mx-auto p-6 hidden">
        <h2 class="text-3xl font-bold text-gray-800 mb-6">Puzzle Results</h2>
        <div id="resultsList" class="space-y-6"></div>
    </div>

    <div id="solveModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-5xl w-full mx-4 max-h-[95vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-6">
                <h3 id="solvePuzzleTitle" class="text-2xl font-bold text-gray-800"></h3>
                <div class="flex items-center space-x-4">
                    <div class="bg-blue-100 px-4 py-2 rounded-lg">
                        <span class="text-sm font-semibold text-blue-800">Time: </span>
                        <span id="puzzleTimer" class="text-lg font-bold text-blue-900">00:00</span>
                    </div>
                    <button onclick="closeSolveModal()" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
                </div>
            </div>
            
            <div class="flex flex-col items-center">
                <div id="solveBoard" class="inline-block border-2 border-gray-800 mb-6"></div>
                
                <div class="w-full max-w-2xl mb-6">
                    <h4 class="text-lg font-semibold mb-3 text-center">Puzzle Description</h4>
                    <div id="solvePuzzleDescription" class="bg-gray-50 p-4 rounded-lg text-center"></div>
                </div>
                
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 w-full max-w-4xl">
                    <div>
                        <h4 class="text-lg font-semibold mb-2">Move Notations</h4>
                        <div id="notationsBox" class="bg-gray-100 p-4 rounded-lg h-32 overflow-y-auto text-sm font-mono mb-4"></div>
                        <div class="flex space-x-4 justify-center">
                            <button onclick="submitSolution()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Submit Solution</button>
                            <button onclick="resetPuzzle()" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Reset</button>
                        </div>
                    </div>
                    <div>
                        <h4 class="text-lg font-semibold mb-2">Chess Notation Guide</h4>
                        <div class="text-sm text-gray-600 bg-blue-50 p-4 rounded-lg">
                            <ul class="space-y-1">
                                <li>• <strong>K</strong>=King, <strong>Q</strong>=Queen, <strong>R</strong>=Rook, <strong>B</strong>=Bishop, <strong>N</strong>=Knight</li>
                                <li>• <strong>+</strong> = Check, <strong>#</strong> = Checkmate</li>
                                <li>• <strong>O-O</strong> = Kingside castling, <strong>O-O-O</strong> = Queenside castling</li>
                                <li>• <strong>x</strong> = Capture, <strong>=</strong> = Promotion</li>
                                <li>• <strong>e.p.</strong> = En passant capture</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="successModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-8 rounded-lg shadow-xl max-w-md w-full mx-4">
            <div class="text-center">
                <div class="text-green-500 text-6xl mb-4">✓</div>
                <h3 class="text-2xl font-bold text-gray-800 mb-4">Success!</h3>
                <p class="text-gray-600 mb-6">Your result has been submitted successfully!</p>
                <button onclick="closeSuccessModal()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg transition duration-200">OK</button>
            </div>
        </div>
    </div>
    
    <div id="submissionResultsModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl results-modal max-w-2xl mx-4 w-full">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-2xl font-bold text-gray-800">Your Submission Results</h3>
                <button onclick="closeSubmissionResultsModal()" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
            </div>
            <div id="submissionResultsContent" class="space-y-4">
                </div>
        </div>
    </div>

    <div id="solutionCountModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-8 rounded-lg shadow-xl max-w-md w-full mx-4">
            <h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">Number of Solutions</h2>
            <div class="mb-6">
                <label class="block text-gray-700 text-sm font-bold mb-2">How many solutions do you want to provide?</label>
                <select id="solutionCount" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500">
                    <option value="1">1 Solution</option>
                    <option value="2">2 Solutions</option>
                </select>
            </div>
            <div class="flex space-x-4">
                <button onclick="startSolutionCapture()" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Continue</button>
                <button onclick="closeSolutionCountModal()" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Cancel</button>
            </div>
        </div>
    </div>

    <div id="solutionCaptureModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-5xl w-full mx-4 max-h-[95vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-6">
                <h3 id="solutionCaptureTitle" class="text-2xl font-bold text-gray-800">Provide Solution</h3>
                <button onclick="closeSolutionCaptureModal()" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
            </div>
            
            <div class="flex flex-col items-center">
                <div id="solutionBoard" class="inline-block border-2 border-gray-800 mb-6"></div>
                
                <div class="w-full max-w-2xl mb-6">
                    <h4 class="text-lg font-semibold mb-3 text-center">Solution Moves</h4>
                    <div id="solutionNotationsBox" class="bg-gray-100 p-4 rounded-lg h-32 overflow-y-auto text-sm font-mono mb-4"></div>
                    <div class="flex space-x-4 justify-center">
                        <button onclick="saveSolutionMoves()" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Save Solution</button>
                        <button onclick="resetSolutionBoard()" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Reset</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="passwordModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-8 rounded-lg shadow-xl max-w-md w-full mx-4">
            <h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">Admin Access Required</h2>
            <div class="mb-4">
                <label class="block text-gray-700 text-sm font-bold mb-2">Enter Password:</label>
                <div class="relative">
                    <input type="password" id="adminPassword" class="w-full px-3 py-2 pr-10 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500" placeholder="Enter admin password">
                    <button type="button" onclick="togglePasswordVisibility()" class="absolute inset-y-0 right-0 pr-3 flex items-center text-gray-400 hover:text-gray-600">
                        <svg id="eyeIcon" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                        </svg>
                        <svg id="eyeOffIcon" class="h-5 w-5 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L3 3m6.878 6.878L21 21" />
                        </svg>
                    </button>
                </div>
            </div>
            <div id="passwordError" class="text-red-500 text-sm mb-4 hidden">Incorrect password. Please try again.</div>
            <div class="flex space-x-4">
                <button onclick="verifyPassword()" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Access</button>
                <button onclick="closePasswordModal()" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentUser = null;
        let puzzles = [];
        let results = {};
        let solutions = {};
        let isFirebaseReady = false;
        let selectedPiece = null;
        let selectedSquare = null;
        let currentTurn = 'white';
        let gameBoard = [];
        let moveHistory = [];
        let currentPuzzleId = null;
        let selectedBankPiece = null;
        let castlingRights = { whiteKing: true, whiteQueenside: true, blackKing: true, blackQueenside: true };
        let enPassantTarget = null;
        let isCreateAuthorized = false;
        let isResultsAuthorized = false;
        let gameEnded = false;
        const adminPassword = 'chessclub@rkv';

        function serializeBoard(board) {
            return board.flat().join('');
        }

        function deserializeBoard(boardString) {
            const board = [];
            for (let i = 0; i < 8; i++) {
                const row = [];
                for (let j = 0; j < 8; j++) {
                    const piece = boardString[i * 8 + j];
                    row.push(piece === ' ' ? '' : piece);
                }
                board.push(row);
            }
            return board;
        }

        async function savePuzzleToFirestore(puzzleData, docId = null) {
            try {
                const sanitizedTitle = puzzleData.title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
                const finalDocId = docId || sanitizedTitle;

                const serializedPuzzleData = {
                    ...puzzleData,
                    board: serializeBoard(puzzleData.board),
                    createdAt: new Date()
                };
                
                const puzzlesCollection = window.firestore.collection(window.db, 'puzzles');
                const docRef = window.firestore.doc(puzzlesCollection, finalDocId);
                await window.firestore.setDoc(docRef, serializedPuzzleData);
                console.log('Puzzle saved to Firestore with ID:', finalDocId);
                return docRef;
            } catch (error) {
                console.error('Error saving puzzle to Firestore:', error);
                alert('Could not save puzzle to the cloud. Check console for errors. It might be a security rule issue.');
                throw error;
            }
        }

        async function saveSolutionToFirestore(puzzleId, solutionsData) {
            try {
                const flatSolutions = solutionsData.map(s => s.join(' ')); 

                const solutionsCollection = window.firestore.collection(window.db, 'solutions');
                const docRef = window.firestore.doc(solutionsCollection, puzzleId);
                await window.firestore.setDoc(docRef, {
                    solutions: solutionsData,
                    lastUpdated: new Date()
                });
                console.log('Solutions saved to Firestore for puzzle ID:', puzzleId);
            } catch (error) {
                console.error('Error saving solutions to Firestore:', error);
                alert('Could not save solutions to the cloud. Check console for errors.');
                throw error;
            }
        }
        
        async function saveResultToFirestore(puzzleId, resultData) {
            try {
                const resultDocRef = window.firestore.doc(window.db, 'results', puzzleId);
                const docSnap = await window.firestore.getDoc(resultDocRef);

                let currentSubmissions = [];
                if (docSnap.exists()) {
                    currentSubmissions = docSnap.data().submissions || [];
                }

                currentSubmissions.push(resultData);

                currentSubmissions.sort((a, b) => {
                    if (a.isCorrect && !b.isCorrect) return -1;
                    if (!a.isCorrect && b.isCorrect) return 1;
                    if (a.isCorrect && b.isCorrect) return a.timeSpent - b.timeSpent;
                    return 0;
                });

                await window.firestore.setDoc(resultDocRef, {
                    puzzleId: puzzleId,
                    submissions: currentSubmissions,
                    lastUpdated: new Date()
                }, { merge: true });

                console.log('Result saved to Firestore for puzzle:', puzzleId);
            } catch (error) {
                console.error('Error saving result to Firestore:', error);
                alert('Could not save result to the cloud. Check console for errors. It might be a security rule issue.');
                throw error;
            }
        }

        // Initialize Firebase and load data
        window.initializeChessApp = async function() {
            try {
                console.log('Initializing Chess Puzzles Hub with Firebase...');
                
                window.firebaseAuth.onAuthStateChanged(window.auth, user => {
                    if (user) {
                        currentUser = user;
                        document.getElementById('currentUser').textContent = user.displayName || user.email;
                        document.getElementById('userInfo').classList.remove('hidden');
                        document.getElementById('authModal').classList.add('hidden');
                        showSection('puzzles');
                    } else {
                        currentUser = null;
                        document.getElementById('userInfo').classList.add('hidden');
                        document.getElementById('authModal').classList.remove('hidden');
                    }
                });

                const puzzlesCollection = window.firestore.collection(window.db, 'puzzles');
                const puzzlesQuery = window.firestore.query(puzzlesCollection, window.firestore.orderBy('createdAt', 'desc'));
                
                window.firestore.onSnapshot(puzzlesQuery, (snapshot) => {
                    const newPuzzles = [];
                    snapshot.forEach((doc) => {
                        const data = doc.data();
                        const createdAt = data.createdAt?.toDate ? data.createdAt.toDate() : new Date(data.createdAt);
                        const board = deserializeBoard(data.board);
                        newPuzzles.push({ id: doc.id, ...data, board, createdAt });
                    });
                    
                    puzzles = newPuzzles;
                    localStorage.setItem('chessPuzzles', JSON.stringify(puzzles));
                    
                    if (!document.getElementById('puzzlesSection').classList.contains('hidden')) {
                        displayPuzzles();
                    }
                    if (!document.getElementById('resultsSection').classList.contains('hidden')) {
                        displayResults();
                    }
                    console.log(`Real-time update: ${puzzles.length} puzzles loaded.`);
                });
                
                const solutionsCollection = window.firestore.collection(window.db, 'solutions');
                window.firestore.onSnapshot(solutionsCollection, (snapshot) => {
                    const newSolutions = {};
                    snapshot.forEach((doc) => {
                        newSolutions[doc.id] = doc.data().solutions || [];
                    });
                    solutions = newSolutions;
                    console.log(`Real-time update: Solutions for ${Object.keys(solutions).length} puzzles loaded.`);
                });

                const resultsCollection = window.firestore.collection(window.db, 'results');
                window.firestore.onSnapshot(resultsCollection, (snapshot) => {
                    const newResults = {};
                    snapshot.forEach((doc) => {
                        newResults[doc.id] = doc.data().submissions || [];
                    });
                    
                    results = newResults;
                    localStorage.setItem('chessResults', JSON.stringify(results));
                    
                    if (!document.getElementById('resultsSection').classList.contains('hidden')) {
                        displayResults();
                    }
                    console.log(`Real-time update: Results for ${Object.keys(results).length} puzzles loaded.`);
                });
                
                isFirebaseReady = true;
                document.getElementById('loadingOverlay').classList.add('hidden');
                console.log('Chess Puzzles Hub initialized successfully with real-time updates!');
                
            } catch (error) {
                console.error('Error initializing Chess Puzzles Hub:', error);
                document.getElementById('loadingOverlay').classList.add('hidden');
                alert('Failed to connect to cloud database. The app will work with local storage only.');
                
                puzzles = JSON.parse(localStorage.getItem('chessPuzzles') || '[]');
                results = JSON.parse(localStorage.getItem('chessResults') || '{}');
                solutions = JSON.parse(localStorage.getItem('chessSolutions') || '{}');
                isFirebaseReady = false;
            }
        };

        function loadAndDisplayResults() {
            displayResults();
        }
        
        let puzzleStartTime = null;
        let timerInterval = null;
        let currentPuzzleSolutions = []; 
        let solutionCaptureData = {
            solutionsNeeded: 0,
            currentSolution: 0,
            capturedSolutions: [],
            puzzleData: null
        };

        const pieceSymbols = {
            'K': '<span style="color: #ffffff; text-shadow: 2px 2px 4px #000000, -1px -1px 2px #000000;">♔</span>', 
            'Q': '<span style="color: #ffffff; text-shadow: 2px 2px 4px #000000, -1px -1px 2px #000000;">♕</span>', 
            'R': '<span style="color: #ffffff; text-shadow: 2px 2px 4px #000000, -1px -1px 2px #000000;">♖</span>', 
            'B': '<span style="color: #ffffff; text-shadow: 2px 2px 4px #000000, -1px -1px 2px #000000;">♗</span>', 
            'N': '<span style="color: #ffffff; text-shadow: 2px 2px 4px #000000, -1px -1px 2px #000000;">♘</span>', 
            'P': '<span style="color: #ffffff; text-shadow: 2px 2px 4px #000000, -1px -1px 2px #000000;">♙</span>',
            'k': '<span style="color: #000000; text-shadow: 1px 1px 2px #ffffff, -1px -1px 1px #ffffff;">♚</span>', 
            'q': '<span style="color: #000000; text-shadow: 1px 1px 2px #ffffff, -1px -1px 1px #ffffff;">♛</span>', 
            'r': '<span style="color: #000000; text-shadow: 1px 1px 2px #ffffff, -1px -1px 1px #ffffff;">♜</span>', 
            'b': '<span style="color: #000000; text-shadow: 1px 1px 2px #ffffff, -1px -1px 1px #ffffff;">♝</span>', 
            'n': '<span style="color: #000000; text-shadow: 1px 1px 2px #ffffff, -1px -1px 1px #ffffff;">♞</span>', 
            'p': '<span style="color: #000000; text-shadow: 1px 1px 2px #ffffff, -1px -1px 1px #ffffff;">♟</span>'
        };

        const initialBoard = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];
        
        window.toggleAuthForm = function() {
            document.getElementById('loginForm').classList.toggle('hidden');
            document.getElementById('registerForm').classList.toggle('hidden');
            document.getElementById('loginError').classList.add('hidden');
            document.getElementById('registerError').classList.add('hidden');
        }

        window.registerUser = async function() {
            const username = document.getElementById('registerUsername').value.trim();
            const email = document.getElementById('registerEmail').value.trim();
            const password = document.getElementById('registerPassword').value.trim();
            const errorDiv = document.getElementById('registerError');

            if (!username || !email || !password) {
                errorDiv.textContent = "Please fill in all fields.";
                errorDiv.classList.remove('hidden');
                return;
            }

            try {
                const userCredential = await window.firebaseAuth.createUserWithEmailAndPassword(window.auth, email, password);
                await window.firebaseAuth.updateProfile(userCredential.user, { displayName: username });
                currentUser = window.auth.currentUser;
                errorDiv.classList.add('hidden');
            } catch (error) {
                errorDiv.textContent = error.message;
                errorDiv.classList.remove('hidden');
            }
        }

        window.loginUser = async function() {
            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value.trim();
            const errorDiv = document.getElementById('loginError');

            if (!email || !password) {
                errorDiv.textContent = "Please fill in all fields.";
                errorDiv.classList.remove('hidden');
                return;
            }

            try {
                await window.firebaseAuth.signInWithEmailAndPassword(window.auth, email, password);
                errorDiv.classList.add('hidden');
            } catch (error) {
                errorDiv.textContent = error.message;
                errorDiv.classList.remove('hidden');
            }
        }

        window.logoutUser = async function() {
            try {
                await window.firebaseAuth.signOut(window.auth);
            } catch (error) {
                console.error("Error signing out: ", error);
            }
        }

        function showSection(section) {
            if (section === 'create' && !isCreateAuthorized) {
                document.getElementById('passwordModal').setAttribute('data-target-section', 'create');
                document.getElementById('passwordModal').classList.remove('hidden');
                return;
            }
            
            if (section === 'results' && !isResultsAuthorized) {
                document.getElementById('passwordModal').setAttribute('data-target-section', 'results');
                document.getElementById('passwordModal').classList.remove('hidden');
                return;
            }

            document.getElementById('createSection').classList.add('hidden');
            document.getElementById('puzzlesSection').classList.add('hidden');
            document.getElementById('resultsSection').classList.add('hidden');
            
            document.getElementById(section + 'Section').classList.remove('hidden');
            
            if (section === 'create') {
                gameBoard = Array(8).fill().map(() => Array(8).fill(''));
                initializeCreateBoard();
            } else if (section === 'puzzles') {
                displayPuzzles();
            } else if (section === 'results') {
                loadAndDisplayResults();
            }
        }

        function initializeCreateBoard() {
            const boardContainer = document.getElementById('createBoard');
            boardContainer.innerHTML = '';
            
            const wrapper = document.createElement('div');
            wrapper.style.display = 'inline-block';
            wrapper.style.position = 'relative';
            
            const topLabels = document.createElement('div');
            topLabels.style.display = 'flex';
            topLabels.style.marginLeft = '20px';
            topLabels.style.marginBottom = '2px';
            for (let col = 0; col < 8; col++) {
                const label = document.createElement('div');
                label.className = 'file-label';
                label.textContent = String.fromCharCode(97 + col);
                topLabels.appendChild(label);
            }
            wrapper.appendChild(topLabels);
            
            const boardDiv = document.createElement('div');
            boardDiv.style.display = 'flex';
            
            const leftLabels = document.createElement('div');
            leftLabels.style.display = 'flex';
            leftLabels.style.flexDirection = 'column';
            leftLabels.style.marginRight = '2px';
            for (let row = 0; row < 8; row++) {
                const label = document.createElement('div');
                label.className = 'rank-label';
                label.textContent = (8 - row).toString();
                leftLabels.appendChild(label);
            }
            boardDiv.appendChild(leftLabels);
            
            const board = document.createElement('div');
            board.style.display = 'grid';
            board.style.gridTemplateColumns = 'repeat(8, 60px)';
            board.style.gridTemplateRows = 'repeat(8, 60px)';
            board.style.border = '2px solid #333';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `chess-square ${(row + col) % 2 === 0 ? 'light-square' : 'dark-square'}`;
                    square.onclick = () => handleCreateSquareClick(row, col);
                    square.innerHTML = pieceSymbols[gameBoard[row][col]] || '';
                    square.id = `create-square-${row}-${col}`;
                    board.appendChild(square);
                }
            }
            boardDiv.appendChild(board);
            wrapper.appendChild(boardDiv);
            
            const bottomLabels = document.createElement('div');
            bottomLabels.style.display = 'flex';
            bottomLabels.style.marginLeft = '20px';
            bottomLabels.style.marginTop = '2px';
            for (let col = 0; col < 8; col++) {
                const label = document.createElement('div');
                label.className = 'file-label';
                label.textContent = String.fromCharCode(97 + col);
                bottomLabels.appendChild(label);
            }
            wrapper.appendChild(bottomLabels);
            
            boardContainer.appendChild(wrapper);
        }

        function handleCreateSquareClick(row, col) {
            if (selectedBankPiece) {
                if (selectedBankPiece === '❌') {
                    gameBoard[row][col] = '';
                } else {
                    const pieceMap = {
                        '♔': 'K', '♕': 'Q', '♖': 'R', '♗': 'B', '♘': 'N', '♙': 'P',
                        '♚': 'k', '♛': 'q', '♜': 'r', '♝': 'b', '♞': 'n', '♟': 'p'
                    };
                    gameBoard[row][col] = pieceMap[selectedBankPiece] || '';
                }
                
                const square = document.getElementById(`create-square-${row}-${col}`);
                if (square) {
                    square.innerHTML = pieceSymbols[gameBoard[row][col]] || '';
                }
                
                document.querySelectorAll('.piece-bank-item').forEach(item => {
                    item.style.backgroundColor = 'white';
                    item.style.borderColor = '#ddd';
                });
                
                selectedBankPiece = null;
            }
        }

        function selectPieceFromBank(piece) {
            selectedBankPiece = piece;
            
            document.querySelectorAll('.piece-bank-item').forEach(item => {
                item.style.backgroundColor = 'white';
                item.style.borderColor = '#ddd';
            });
            
            event.target.style.backgroundColor = '#e3f2fd';
            event.target.style.borderColor = '#2196f3';
        }

        function clearBoard() {
            gameBoard = Array(8).fill().map(() => Array(8).fill(''));
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.getElementById(`create-square-${row}-${col}`);
                    if (square) {
                        square.innerHTML = '';
                    }
                }
            }
            
            selectedBankPiece = null;
            document.querySelectorAll('.piece-bank-item').forEach(item => {
                item.style.backgroundColor = 'white';
                item.style.borderColor = '#ddd';
            });
        }

        function validateKings() {
            let whiteKingCount = 0;
            let blackKingCount = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameBoard[row][col];
                    if (piece === 'K') whiteKingCount++;
                    if (piece === 'k') blackKingCount++;
                }
            }
            
            const errors = [];
            if (whiteKingCount === 0) errors.push('White King is missing');
            if (whiteKingCount > 1) errors.push('Multiple White Kings found (only one allowed)');
            if (blackKingCount === 0) errors.push('Black King is missing');
            if (blackKingCount > 1) errors.push('Multiple Black Kings found (only one allowed)');
            
            return errors;
        }
        
        function saveWithSolution() {
            const title = document.getElementById('puzzleTitle').value.trim();
            const description = document.getElementById('puzzleDescription').value.trim();
            const firstMove = document.getElementById('firstMove').value;
            
            if (!title) {
                alert('Please enter a puzzle title before saving.');
                return;
            }

            if (!description) {
                alert('Please enter a puzzle description before saving.');
                return;
            }

            const kingErrors = validateKings();
            if (kingErrors.length > 0) {
                alert('Board validation failed:\n\n' + kingErrors.join('\n') + '\n\nPlease fix these issues before saving the puzzle.');
                return;
            }

            solutionCaptureData.puzzleData = {
                title: title,
                description: description,
                board: serializeBoard(JSON.parse(JSON.stringify(gameBoard))),
                firstMove: firstMove,
                createdBy: currentUser.displayName,
                hasSolutions: true
            };

            document.getElementById('solutionCountModal').classList.remove('hidden');
        }

        async function saveWithoutSolution() {
            const title = document.getElementById('puzzleTitle').value.trim();
            const description = document.getElementById('puzzleDescription').value.trim();
            const firstMove = document.getElementById('firstMove').value;
            
            if (!title) {
                alert('Please enter a puzzle title before saving.');
                return;
            }

            if (!description) {
                alert('Please enter a puzzle description before saving.');
                return;
            }

            const kingErrors = validateKings();
            if (kingErrors.length > 0) {
                alert('Board validation failed:\n\n' + kingErrors.join('\n') + '\n\nPlease fix these issues before saving the puzzle.');
                return;
            }
            
            const sanitizedTitle = title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');

            const puzzleData = {
                title: title,
                description: description,
                board: serializeBoard(JSON.parse(JSON.stringify(gameBoard))),
                firstMove: firstMove,
                createdBy: currentUser.displayName,
                hasSolutions: false
            };

            const saveButton = event.target;
            const originalText = saveButton.textContent;
            saveButton.textContent = 'Saving...';
            saveButton.disabled = true;

            try {
                await savePuzzleToFirestore(puzzleData, sanitizedTitle);
                
                document.getElementById('puzzleTitle').value = '';
                document.getElementById('puzzleDescription').value = '';
                document.getElementById('firstMove').value = 'white';
                
                alert('Puzzle saved successfully and is now available globally!');
                
                showSection('puzzles');
            } catch (error) {
            } finally {
                saveButton.textContent = originalText;
                saveButton.disabled = false;
            }
        }

        function closeSolutionCountModal() {
            document.getElementById('solutionCountModal').classList.add('hidden');
        }

        function startSolutionCapture() {
            const count = parseInt(document.getElementById('solutionCount').value);
            solutionCaptureData.solutionsNeeded = count;
            solutionCaptureData.currentSolution = 1;
            solutionCaptureData.capturedSolutions = [];
            
            document.getElementById('solutionCountModal').classList.add('hidden');
            openSolutionCaptureModal();
        }

        function openSolutionCaptureModal() {
            gameBoard = deserializeBoard(solutionCaptureData.puzzleData.board);
            moveHistory = [];
            currentTurn = solutionCaptureData.puzzleData.firstMove || 'white';
            gameEnded = false;
            
            document.getElementById('solutionCaptureTitle').textContent = 
                `Provide Solution ${solutionCaptureData.currentSolution} of ${solutionCaptureData.solutionsNeeded}`;
            document.getElementById('solutionNotationsBox').innerHTML = '';
            
            initializeSolutionBoard();
            document.getElementById('solutionCaptureModal').classList.remove('hidden');
        }

        function initializeSolutionBoard() {
            const boardContainer = document.getElementById('solutionBoard');
            boardContainer.innerHTML = '';
            
            const wrapper = document.createElement('div');
            wrapper.style.display = 'inline-block';
            wrapper.style.position = 'relative';
            
            const topLabels = document.createElement('div');
            topLabels.style.display = 'flex';
            topLabels.style.marginLeft = '20px';
            topLabels.style.marginBottom = '2px';
            for (let col = 0; col < 8; col++) {
                const label = document.createElement('div');
                label.className = 'file-label';
                label.textContent = String.fromCharCode(97 + col);
                topLabels.appendChild(label);
            }
            wrapper.appendChild(topLabels);
            
            const boardDiv = document.createElement('div');
            boardDiv.style.display = 'flex';
            
            const leftLabels = document.createElement('div');
            leftLabels.style.display = 'flex';
            leftLabels.style.flexDirection = 'column';
            leftLabels.style.marginRight = '2px';
            for (let row = 0; row < 8; row++) {
                const label = document.createElement('div');
                label.className = 'rank-label';
                label.textContent = (8 - row).toString();
                leftLabels.appendChild(label);
            }
            boardDiv.appendChild(leftLabels);
            
            const board = document.createElement('div');
            board.style.display = 'grid';
            board.style.gridTemplateColumns = 'repeat(8, 60px)';
            board.style.gridTemplateRows = 'repeat(8, 60px)';
            board.style.border = '2px solid #333';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `chess-square ${(row + col) % 2 === 0 ? 'light-square' : 'dark-square'}`;
                    square.onclick = () => handleSolutionSquareClick(row, col);
                    square.innerHTML = pieceSymbols[gameBoard[row][col]] || '';
                    square.id = `solution-square-${row}-${col}`;
                    board.appendChild(square);
                }
            }
            boardDiv.appendChild(board);
            wrapper.appendChild(boardDiv);
            
            const bottomLabels = document.createElement('div');
            bottomLabels.style.display = 'flex';
            bottomLabels.style.marginLeft = '20px';
            bottomLabels.style.marginTop = '2px';
            for (let col = 0; col < 8; col++) {
                const label = document.createElement('div');
                label.className = 'file-label';
                label.textContent = String.fromCharCode(97 + col);
                bottomLabels.appendChild(label);
            }
            wrapper.appendChild(bottomLabels);
            
            boardContainer.appendChild(wrapper);
        }

        function handleSolutionSquareClick(row, col) {
            const piece = gameBoard[row][col];
            
            if (selectedSquare) {
                if (isValidMove(selectedSquare.row, selectedSquare.col, row, col)) {
                    makeSolutionMove(selectedSquare.row, selectedSquare.col, row, col);
                }
                clearSolutionSelection();
            } else if (piece && isPieceColor(piece, currentTurn)) {
                selectedSquare = { row, col };
                document.getElementById(`solution-square-${row}-${col}`).classList.add('selected');
                showSolutionPossibleMoves(row, col);
            }
        }

        function showSolutionPossibleMoves(row, col) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(row, col, r, c)) {
                        document.getElementById(`solution-square-${r}-${c}`).classList.add('possible-move');
                    }
                }
            }
        }

        function clearSolutionSelection() {
            if (selectedSquare) {
                document.getElementById(`solution-square-${selectedSquare.row}-${selectedSquare.col}`).classList.remove('selected');
            }
            selectedSquare = null;
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const square = document.getElementById(`solution-square-${r}-${c}`);
                    if (square) {
                        square.classList.remove('possible-move');
                    }
                }
            }
        }

        function makeSolutionMove(fromRow, fromCol, toRow, toCol) {
            const piece = gameBoard[fromRow][fromCol];
            const capturedPiece = gameBoard[toRow][toCol];
            let specialMove = '';
            
            if (piece.toLowerCase() === 'p' && enPassantTarget && 
                enPassantTarget.row === toRow && enPassantTarget.col === toCol) {
                const capturedPawnRow = isPieceColor(piece, 'white') ? toRow + 1 : toRow - 1;
                gameBoard[capturedPawnRow][toCol] = '';
                specialMove = 'enpassant';
            }
            
            if (piece.toLowerCase() === 'k' && Math.abs(toCol - fromCol) === 2) {
                const isKingside = toCol > fromCol;
                const rookFromCol = isKingside ? 7 : 0;
                const rookToCol = isKingside ? 5 : 3;
                const rook = gameBoard[fromRow][rookFromCol];
                
                gameBoard[fromRow][rookToCol] = rook;
                gameBoard[fromRow][rookFromCol] = '';
                specialMove = isKingside ? 'castleKing' : 'castleQueen';
            }
            
            gameBoard[toRow][toCol] = piece;
            gameBoard[fromRow][fromCol] = '';
            
            if (piece.toLowerCase() === 'k') {
                if (isPieceColor(piece, 'white')) {
                    castlingRights.whiteKing = false;
                    castlingRights.whiteQueenside = false;
                } else {
                    castlingRights.blackKing = false;
                    castlingRights.blackQueenside = false;
                }
            }
            
            if (piece.toLowerCase() === 'r') {
                if (isPieceColor(piece, 'white')) {
                    if (fromCol === 0) castlingRights.whiteQueenside = false;
                    if (fromCol === 7) castlingRights.whiteKing = false;
                } else {
                    if (fromCol === 0) castlingRights.blackQueenside = false;
                    if (fromCol === 7) castlingRights.blackKing = false;
                }
            }
            
            enPassantTarget = null;
            if (piece.toLowerCase() === 'p' && Math.abs(toRow - fromRow) === 2) {
                enPassantTarget = {
                    row: isPieceColor(piece, 'white') ? fromRow - 1 : fromRow + 1,
                    col: fromCol
                };
            }
            
            const notation = generateNotation(piece, fromRow, fromCol, toRow, toCol, capturedPiece, specialMove);
            moveHistory.push(notation);
            
            initializeSolutionBoard();
            updateSolutionNotations();
            
            currentTurn = currentTurn === 'white' ? 'black' : 'white';
            
            const opponentColor = currentTurn === 'white' ? 'black' : 'white';
            if (isInCheck(opponentColor) && isCheckmate(opponentColor)) {
                gameEnded = true;
                if (!moveHistory[moveHistory.length - 1].includes('#')) {
                    moveHistory[moveHistory.length - 1] = moveHistory[moveHistory.length - 1].replace('+', '#');
                    updateSolutionNotations();
                }
            }
        }

        function updateSolutionNotations() {
            const notationsBox = document.getElementById('solutionNotationsBox');
            notationsBox.innerHTML = moveHistory.map((move, index) => {
                const moveNumber = Math.floor(index / 2) + 1;
                const isWhiteMove = index % 2 === 0;
                return isWhiteMove ? `${moveNumber}. ${move}` : ` ${move}`;
            }).join(' ');
            notationsBox.scrollTop = notationsBox.scrollHeight;
        }

        async function saveSolutionMoves() {
            if (moveHistory.length === 0) {
                alert('Please make some moves before saving the solution');
                return;
            }

            solutionCaptureData.capturedSolutions.push([...moveHistory]);
            
            if (solutionCaptureData.currentSolution < solutionCaptureData.solutionsNeeded) {
                solutionCaptureData.currentSolution++;
                openSolutionCaptureModal();
            } else {
                const title = document.getElementById('puzzleTitle').value.trim();
                const sanitizedTitle = title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
                const description = document.getElementById('puzzleDescription').value.trim();
                
                const puzzleData = {
                    title: title,
                    description: description,
                    board: serializeBoard(gameBoard),
                    firstMove: solutionCaptureData.puzzleData.firstMove,
                    createdBy: currentUser.displayName,
                    hasSolutions: true
                };

                const saveButton = event.target;
                const originalText = saveButton.textContent;
                saveButton.textContent = 'Saving...';
                saveButton.disabled = true;

                try {
                    await savePuzzleToFirestore(puzzleData, sanitizedTitle);
                    
                    await saveSolutionToFirestore(sanitizedTitle, solutionCaptureData.capturedSolutions);
                    
                    document.getElementById('puzzleTitle').value = '';
                    document.getElementById('puzzleDescription').value = '';
                    document.getElementById('firstMove').value = 'white';
                    
                    closeSolutionCaptureModal();
                    
                    alert('Puzzle with solutions saved successfully and is now available globally!');
                    
                    showSection('puzzles');
                } catch (error) {
                } finally {
                    saveButton.textContent = originalText;
                    saveButton.disabled = false;
                }
            }
        }

        function resetSolutionBoard() {
            gameBoard = deserializeBoard(solutionCaptureData.puzzleData.board);
            moveHistory = [];
            currentTurn = solutionCaptureData.puzzleData.firstMove || 'white';
            gameEnded = false;
            
            castlingRights = { whiteKing: true, whiteQueenside: true, blackKing: true, blackQueenside: true };
            enPassantTarget = null;
            
            initializeSolutionBoard();
            document.getElementById('solutionNotationsBox').innerHTML = '';
        }

        function closeSolutionCaptureModal() {
            document.getElementById('solutionCaptureModal').classList.add('hidden');
            clearSolutionSelection();
        }

        function deletePuzzleFromCard(puzzleId, puzzleName, event) {
            event.stopPropagation();
            
            if (!confirm(`Are you sure you want to delete "${puzzleName}"? This action cannot be undone.`)) {
                return;
            }

            document.getElementById('passwordModal').setAttribute('data-delete-puzzle-id', puzzleId);
            document.getElementById('passwordModal').setAttribute('data-target-section', 'delete-confirm');
            document.getElementById('passwordModal').classList.remove('hidden');
        }

        function confirmPuzzleDeletion(puzzleId) {
            const puzzleIndex = puzzles.findIndex(p => p.id == puzzleId);
            if (puzzleIndex === -1) {
                alert('Puzzle not found');
                return;
            }
            
            try {
                const puzzleDocRef = window.firestore.doc(window.db, 'puzzles', puzzleId);
                window.firestore.deleteDoc(puzzleDocRef);

                const resultDocRef = window.firestore.doc(window.db, 'results', puzzleId);
                window.firestore.deleteDoc(resultDocRef);
                
                const solutionDocRef = window.firestore.doc(window.db, 'solutions', puzzleId);
                window.firestore.deleteDoc(solutionDocRef);
                
                alert(`Puzzle "${puzzles[puzzleIndex].title}" has been deleted successfully! The view will update shortly.`);
            } catch (error) {
                console.error("Error deleting puzzle from Firestore: ", error);
                alert("Failed to delete puzzle from the cloud.");
            }
        }

        function displayPuzzles() {
            const todayPuzzleList = document.getElementById('todayPuzzle');
            const archivedPuzzlesList = document.getElementById('archivedPuzzles');
            todayPuzzleList.innerHTML = '';
            archivedPuzzlesList.innerHTML = '';

            if (puzzles.length === 0) {
                todayPuzzleList.innerHTML = '<div class="text-center text-gray-500 py-8">No puzzles available yet. Create the first one!</div>';
                return;
            }

            const today = new Date().toISOString().split('T')[0];
            let hasTodayPuzzle = false;

            puzzles.forEach(puzzle => {
                const puzzleDate = new Date(puzzle.createdAt).toISOString().split('T')[0];
                const puzzleCard = createPuzzleCard(puzzle);
                
                if (puzzleDate === today && !hasTodayPuzzle) {
                    todayPuzzleList.appendChild(puzzleCard);
                    hasTodayPuzzle = true;
                } else {
                    archivedPuzzlesList.appendChild(puzzleCard);
                }
            });

            if (!hasTodayPuzzle) {
                 todayPuzzleList.innerHTML = '<div class="text-center text-gray-500 py-8">No new puzzle for today. Check back later!</div>';
            }
        }
        
        function createPuzzleCard(puzzle) {
            const puzzleCard = document.createElement('div');
            puzzleCard.className = 'bg-white rounded-lg shadow-lg p-6';
            const firstMoveText = puzzle.firstMove === 'white' ? 'White to move' : 'Black to move';
            const firstMoveColor = puzzle.firstMove === 'white' ? 'text-blue-600' : 'text-gray-800';
            
            puzzleCard.innerHTML = `
                <div class="flex justify-between items-start mb-4">
                    <h3 class="text-xl font-bold text-gray-800">${puzzle.title}</h3>
                    <span class="text-sm text-gray-500">${new Date(puzzle.createdAt).toLocaleDateString()}</span>
                </div>
                <p class="text-gray-600 mb-3">${puzzle.description}</p>
                <div class="mb-4">
                    <span class="inline-block px-3 py-1 text-sm font-semibold ${firstMoveColor} bg-gray-100 rounded-full">
                        ${firstMoveText}
                    </span>
                </div>
                <div class="flex justify-between items-center">
                    <span class="text-sm text-gray-500">Created by: ${puzzle.createdBy}</span>
                    <button onclick="solvePuzzle('${puzzle.id}')" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Solve Puzzle</button>
                </div>
            `;
            return puzzleCard;
        }

        function toggleArchivedPuzzles() {
            const archivedSection = document.getElementById('archivedPuzzles');
            const arrow = document.getElementById('archiveArrow');
            if (archivedSection.classList.contains('hidden')) {
                archivedSection.classList.remove('hidden');
                arrow.classList.add('rotate-180');
            } else {
                archivedSection.classList.add('hidden');
                arrow.classList.remove('rotate-180');
            }
        }


        function startPuzzleTimer() {
            puzzleStartTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function updateTimer() {
            if (puzzleStartTime) {
                const elapsed = Math.floor((Date.now() - puzzleStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('puzzleTimer').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        function stopPuzzleTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function getElapsedTime() {
            if (puzzleStartTime) {
                return Math.floor((Date.now() - puzzleStartTime) / 1000);
            }
            return 0;
        }

        function solvePuzzle(puzzleId) {
            const puzzle = puzzles.find(p => p.id == puzzleId);
            if (!puzzle) {
                console.error('Puzzle not found:', puzzleId);
                alert('Puzzle not found. Please try refreshing the page.');
                return;
            }

            currentPuzzleId = puzzleId;
            currentPuzzleSolutions = solutions[puzzleId] || [];

            gameBoard = puzzle.board ? JSON.parse(JSON.stringify(puzzle.board)) : [];

            if (gameBoard.length === 0) {
                console.error('Board data for puzzle is empty or invalid.');
                alert('Puzzle board data is corrupted. Please select another puzzle.');
                return;
            }

            moveHistory = [];
            currentTurn = puzzle.firstMove || 'white';
            gameEnded = false;
            selectedSquare = null;
            
            castlingRights = { whiteKing: true, whiteQueenside: true, blackKing: true, blackQueenside: true };
            enPassantTarget = null;
            
            document.getElementById('solvePuzzleTitle').textContent = puzzle.title;
            document.getElementById('solvePuzzleDescription').textContent = puzzle.description;
            document.getElementById('notationsBox').innerHTML = '';
            document.getElementById('puzzleTimer').textContent = '00:00';
            
            initializeSolveBoard();
            highlightKingInCheck();
            document.getElementById('solveModal').classList.remove('hidden');
            
            startPuzzleTimer();
        }

        function initializeSolveBoard() {
            if (!gameBoard || gameBoard.length === 0) {
                console.error("gameBoard is not initialized. Cannot render board.");
                return;
            }

            const boardContainer = document.getElementById('solveBoard');
            boardContainer.innerHTML = '';
            
            const wrapper = document.createElement('div');
            wrapper.style.display = 'inline-block';
            wrapper.style.position = 'relative';
            
            const topLabels = document.createElement('div');
            topLabels.style.display = 'flex';
            topLabels.style.marginLeft = '20px';
            topLabels.style.marginBottom = '2px';
            for (let col = 0; col < 8; col++) {
                const label = document.createElement('div');
                label.className = 'file-label';
                label.textContent = String.fromCharCode(97 + col);
                topLabels.appendChild(label);
            }
            wrapper.appendChild(topLabels);
            
            const boardDiv = document.createElement('div');
            boardDiv.style.display = 'flex';
            
            const leftLabels = document.createElement('div');
            leftLabels.style.display = 'flex';
            leftLabels.style.flexDirection = 'column';
            leftLabels.style.marginRight = '2px';
            for (let row = 0; row < 8; row++) {
                const label = document.createElement('div');
                label.className = 'rank-label';
                label.textContent = (8 - row).toString();
                leftLabels.appendChild(label);
            }
            boardDiv.appendChild(leftLabels);
            
            const board = document.createElement('div');
            board.style.display = 'grid';
            board.style.gridTemplateColumns = 'repeat(8, 60px)';
            board.style.gridTemplateRows = 'repeat(8, 60px)';
            board.style.border = '2px solid #333';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `chess-square ${(row + col) % 2 === 0 ? 'light-square' : 'dark-square'}`;
                    square.onclick = () => handleSquareClick(row, col);
                    square.innerHTML = pieceSymbols[gameBoard[row][col]] || '';
                    square.id = `square-${row}-${col}`;
                    board.appendChild(square);
                }
            }
            boardDiv.appendChild(board);
            wrapper.appendChild(boardDiv);
            
            const bottomLabels = document.createElement('div');
            bottomLabels.style.display = 'flex';
            bottomLabels.style.marginLeft = '20px';
            bottomLabels.style.marginTop = '2px';
            for (let col = 0; col < 8; col++) {
                const label = document.createElement('div');
                label.className = 'file-label';
                label.textContent = String.fromCharCode(97 + col);
                bottomLabels.appendChild(label);
            }
            wrapper.appendChild(bottomLabels);
            
            boardContainer.appendChild(wrapper);
        }

        function handleSquareClick(row, col) {
            const piece = gameBoard[row][col];
            
            if (selectedSquare) {
                if (isValidMove(selectedSquare.row, selectedSquare.col, row, col)) {
                    makeMove(selectedSquare.row, selectedSquare.col, row, col);
                }
                clearSelection();
            } else if (piece && isPieceColor(piece, currentTurn)) {
                selectedSquare = { row, col };
                document.getElementById(`square-${row}-${col}`).classList.add('selected');
                showPossibleMoves(row, col);
            }
        }

        function isPieceColor(piece, color) {
            if (color === 'white') {
                return piece === piece.toUpperCase();
            } else {
                return piece === piece.toLowerCase();
            }
        }

        function showPossibleMoves(row, col) {
            const piece = gameBoard[row][col].toLowerCase();
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(row, col, r, c)) {
                        document.getElementById(`square-${r}-${c}`).classList.add('possible-move');
                    }
                }
            }
        }

        function clearSelection() {
            if (selectedSquare) {
                document.getElementById(`square-${selectedSquare.row}-${selectedSquare.col}`).classList.remove('selected');
            }
            selectedSquare = null;
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    document.getElementById(`square-${r}-${c}`).classList.remove('possible-move');
                }
            }
        }

        function isValidMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow === toRow && fromCol === toCol) return false;
            if (gameEnded) return false;
            
            const piece = gameBoard[fromRow][fromCol].toLowerCase();
            const targetPiece = gameBoard[toRow][toCol];
            
            if (targetPiece && isPieceColor(targetPiece, currentTurn)) return false;
            
            if (isInCheck(currentTurn)) {
                const originalPiece = gameBoard[toRow][toCol];
                gameBoard[toRow][toCol] = gameBoard[fromRow][fromCol];
                gameBoard[fromRow][fromCol] = '';
                
                const stillInCheck = isInCheck(currentTurn);
                
                gameBoard[fromRow][fromCol] = gameBoard[toRow][toCol];
                gameBoard[toRow][toCol] = originalPiece;
                
                if (stillInCheck) return false;
            }
            
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);
            
            switch (piece) {
                case 'p':
                    const direction = isPieceColor(gameBoard[fromRow][fromCol], 'white') ? -1 : 1;
                    const startRow = isPieceColor(gameBoard[fromRow][fromCol], 'white') ? 6 : 1;
                    
                    if (colDiff === 0) {
                        if (targetPiece) return false;
                        if (toRow === fromRow + direction) return true;
                        if (fromRow === startRow && toRow === fromRow + 2 * direction && !gameBoard[fromRow + direction][fromCol]) return true;
                    } else if (colDiff === 1 && toRow === fromRow + direction) {
                        if (targetPiece !== '') return true;
                        if (enPassantTarget && enPassantTarget.row === toRow && enPassantTarget.col === toCol) {
                            return true;
                        }
                    }
                    return false;
                    
                case 'r':
                    if (rowDiff === 0 || colDiff === 0) {
                        return isPathClear(fromRow, fromCol, toRow, toCol);
                    }
                    return false;
                    
                case 'n':
                    return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
                    
                case 'b':
                    if (rowDiff === colDiff) {
                        return isPathClear(fromRow, fromCol, toRow, toCol);
                    }
                    return false;
                    
                case 'q':
                    if (rowDiff === 0 || colDiff === 0 || rowDiff === colDiff) {
                        return isPathClear(fromRow, fromCol, toRow, toCol);
                    }
                    return false;
                    
                case 'k':
                    if (rowDiff <= 1 && colDiff <= 1) return true;
                    
                    if (rowDiff === 0 && colDiff === 2) {
                        const isWhite = isPieceColor(gameBoard[fromRow][fromCol], 'white');
                        const kingRow = isWhite ? 7 : 0;
                        
                        if (fromRow !== kingRow) return false;
                        
                        if (toCol === 6) {
                            if (isWhite && !castlingRights.whiteKing) return false;
                            if (!isWhite && !castlingRights.blackKing) return false;
                            
                            if (gameBoard[kingRow][7] === (isWhite ? 'R' : 'r') && 
                                isPathClear(fromRow, fromCol, fromRow, 7)) {
                                return !isInCheck(currentTurn) && 
                                       !wouldBeInCheck(fromRow, fromCol, fromRow, fromCol + 1) &&
                                       !wouldBeInCheck(fromRow, fromCol, fromRow, fromCol + 2);
                            }
                        }
                        
                        if (toCol === 2) {
                            if (isWhite && !castlingRights.whiteQueenside) return false;
                            if (!isWhite && !castlingRights.blackQueenside) return false;
                            
                            if (gameBoard[kingRow][0] === (isWhite ? 'R' : 'r') && 
                                isPathClear(fromRow, fromCol, fromRow, 0)) {
                                return !isInCheck(currentTurn) && 
                                       !wouldBeInCheck(fromRow, fromCol, fromRow, fromCol - 1) &&
                                       !wouldBeInCheck(fromRow, fromCol, fromRow, fromCol - 2);
                            }
                        }
                    }
                    return false;
                    
                default:
                    return false;
            }
        }

        function isPathClear(fromRow, fromCol, toRow, toCol) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;
            
            let currentRow = fromRow + rowStep;
            let currentCol = fromCol + colStep;
            
            while (currentRow !== toRow || currentCol !== toCol) {
                if (gameBoard[currentRow][currentCol] !== '') return false;
                currentRow += rowStep;
                currentCol += colStep;
            }
            
            return true;
        }

        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = gameBoard[fromRow][fromCol];
            const capturedPiece = gameBoard[toRow][toCol];
            let specialMove = '';
            
            if (piece.toLowerCase() === 'p' && enPassantTarget && 
                enPassantTarget.row === toRow && enPassantTarget.col === toCol) {
                const capturedPawnRow = isPieceColor(piece, 'white') ? toRow + 1 : toRow - 1;
                gameBoard[capturedPawnRow][toCol] = '';
                specialMove = 'enpassant';
            }
            
            if (piece.toLowerCase() === 'k' && Math.abs(toCol - fromCol) === 2) {
                const isKingside = toCol > fromCol;
                const rookFromCol = isKingside ? 7 : 0;
                const rookToCol = isKingside ? 5 : 3;
                const rook = gameBoard[fromRow][rookFromCol];
                
                gameBoard[fromRow][rookToCol] = rook;
                gameBoard[fromRow][rookFromCol] = '';
                specialMove = isKingside ? 'castleKing' : 'castleQueen';
            }
            
            gameBoard[toRow][toCol] = piece;
            gameBoard[fromRow][fromCol] = '';
            
            if (piece.toLowerCase() === 'k') {
                if (isPieceColor(piece, 'white')) {
                    castlingRights.whiteKing = false;
                    castlingRights.whiteQueenside = false;
                } else {
                    castlingRights.blackKing = false;
                    castlingRights.blackQueenside = false;
                }
            }
            
            if (piece.toLowerCase() === 'r') {
                if (isPieceColor(piece, 'white')) {
                    if (fromCol === 0) castlingRights.whiteQueenside = false;
                    if (fromCol === 7) castlingRights.whiteKing = false;
                } else {
                    if (fromCol === 0) castlingRights.blackQueenside = false;
                    if (fromCol === 7) castlingRights.blackKing = false;
                }
            }
            
            enPassantTarget = null;
            if (piece.toLowerCase() === 'p' && Math.abs(toRow - fromRow) === 2) {
                enPassantTarget = {
                    row: isPieceColor(piece, 'white') ? fromRow - 1 : fromRow + 1,
                    col: fromCol
                };
            }
            
            const notation = generateNotation(piece, fromRow, fromCol, toRow, toCol, capturedPiece, specialMove);
            moveHistory.push(notation);
            
            initializeSolveBoard();
            updateNotations();
            
            currentTurn = currentTurn === 'white' ? 'black' : 'white';
            
            const opponentColor = currentTurn === 'white' ? 'black' : 'white';
            if (isInCheck(opponentColor) && isCheckmate(opponentColor)) {
                gameEnded = true;
                if (!moveHistory[moveHistory.length - 1].includes('#')) {
                    moveHistory[moveHistory.length - 1] = moveHistory[moveHistory.length - 1].replace('+', '#');
                    updateNotations();
                }
                setTimeout(() => {
                    alert(`Checkmate! ${currentTurn === 'white' ? 'White' : 'Black'} wins!`);
                }, 100);
            }
            
            highlightKingInCheck();
        }

        function generateNotation(piece, fromRow, fromCol, toRow, toCol, capturedPiece, specialMove) {
            const files = 'abcdefgh';
            const ranks = '87654321';
            
            let notation = '';
            
            if (specialMove === 'castleKing') {
                notation = 'O-O';
            } else if (specialMove === 'castleQueen') {
                notation = 'O-O-O';
            } else {
                const pieceType = piece.toUpperCase();
                
                if (pieceType !== 'P') {
                    notation += pieceType;
                }
                
                if (capturedPiece || specialMove === 'enpassant') {
                    if (pieceType === 'P') {
                        notation += files[fromCol];
                    }
                    notation += 'x';
                }
                
                notation += files[toCol] + ranks[toRow];
                
                if (specialMove === 'enpassant') {
                    notation += ' e.p.';
                }
            }
            
            const opponentColor = currentTurn === 'white' ? 'black' : 'white';
            if (isInCheck(opponentColor)) {
                notation += '+';
            }
            
            return notation;
        }

        function wouldBeInCheck(fromRow, fromCol, toRow, toCol) {
            const originalPiece = gameBoard[toRow][toCol];
            const movingPiece = gameBoard[fromRow][fromCol];
            
            gameBoard[toRow][toCol] = movingPiece;
            gameBoard[fromRow][fromCol] = '';
            
            const inCheck = isInCheck(currentTurn);
            
            gameBoard[fromRow][fromCol] = movingPiece;
            gameBoard[toRow][toCol] = originalPiece;
            
            return inCheck;
        }

        function isInCheck(color) {
            let kingRow = -1, kingCol = -1;
            const kingSymbol = color === 'white' ? 'K' : 'k';
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (gameBoard[r][c] === kingSymbol) {
                        kingRow = r;
                        kingCol = c;
                        break;
                    }
                }
                if (kingRow !== -1) break;
            }
            
            if (kingRow === -1) return false;
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = gameBoard[r][c];
                    if (piece && !isPieceColor(piece, color)) {
                        const tempEnPassant = enPassantTarget;
                        enPassantTarget = null;
                        
                        if (canPieceAttack(r, c, kingRow, kingCol)) {
                            enPassantTarget = tempEnPassant;
                            return true;
                        }
                        
                        enPassantTarget = tempEnPassant;
                    }
                }
            }
            
            return false;
        }

        function canPieceAttack(fromRow, fromCol, toRow, toCol) {
            const piece = gameBoard[fromRow][fromCol].toLowerCase();
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);
            
            switch (piece) {
                case 'p':
                    const direction = isPieceColor(gameBoard[fromRow][fromCol], 'white') ? -1 : 1;
                    return colDiff === 1 && toRow === fromRow + direction;
                case 'r':
                    return (rowDiff === 0 || colDiff === 0) && isPathClear(fromRow, fromCol, toRow, toCol);
                case 'n':
                    return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
                case 'b':
                    return rowDiff === colDiff && isPathClear(fromRow, fromCol, toRow, toCol);
                case 'q':
                    return (rowDiff === 0 || colDiff === 0 || rowDiff === colDiff) && isPathClear(fromRow, fromCol, toRow, toCol);
                case 'k':
                    return rowDiff <= 1 && colDiff <= 1;
                default:
                    return false;
            }
        }

        function isCheckmate(color) {
            if (!isInCheck(color)) return false;
            
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = gameBoard[fromRow][fromCol];
                    if (piece && isPieceColor(piece, color)) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (fromRow === toRow && fromCol === toCol) continue;
                                
                                if (isBasicMoveValid(fromRow, fromCol, toRow, toCol)) {
                                    const originalPiece = gameBoard[toRow][toCol];
                                    const originalEnPassant = enPassantTarget;
                                    
                                    let enPassantCaptured = null;
                                    if (piece.toLowerCase() === 'p' && enPassantTarget && 
                                        enPassantTarget.row === toRow && enPassantTarget.col === toCol) {
                                        const capturedPawnRow = isPieceColor(piece, 'white') ? toRow + 1 : toRow - 1;
                                        enPassantCaptured = gameBoard[capturedPawnRow][toCol];
                                        gameBoard[capturedPawnRow][toCol] = '';
                                    }
                                    
                                    gameBoard[toRow][toCol] = piece;
                                    gameBoard[fromRow][fromCol] = '';
                                    
                                    const stillInCheck = isInCheck(color);
                                    
                                    gameBoard[fromRow][fromCol] = piece;
                                    gameBoard[toRow][toCol] = originalPiece;
                                    enPassantTarget = originalEnPassant;
                                    
                                    if (enPassantCaptured !== null) {
                                        const capturedPawnRow = isPieceColor(piece, 'white') ? toRow + 1 : toRow - 1;
                                        gameBoard[capturedPawnRow][toCol] = enPassantCaptured;
                                    }
                                    
                                    if (!stillInCheck) {
                                        return false;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            return true;
        }

        function isBasicMoveValid(fromRow, fromCol, toRow, toCol) {
            if (fromRow === toRow && fromCol === toCol) return false;
            
            const piece = gameBoard[fromRow][fromCol].toLowerCase();
            const targetPiece = gameBoard[toRow][toCol];
            
            if (targetPiece && isPieceColor(targetPiece, isPieceColor(gameBoard[fromRow][fromCol], 'white') ? 'white' : 'black')) return false;
            
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);
            
            switch (piece) {
                case 'p':
                    const direction = isPieceColor(gameBoard[fromRow][fromCol], 'white') ? -1 : 1;
                    const startRow = isPieceColor(gameBoard[fromRow][fromCol], 'white') ? 6 : 1;
                    
                    if (colDiff === 0) {
                        if (targetPiece) return false;
                        if (toRow === fromRow + direction) return true;
                        if (fromRow === startRow && toRow === fromRow + 2 * direction && !gameBoard[fromRow + direction][fromCol]) return true;
                    } else if (colDiff === 1 && toRow === fromRow + direction) {
                        if (targetPiece !== '') return true;
                        if (enPassantTarget && enPassantTarget.row === toRow && enPassantTarget.col === toCol) {
                            return true;
                        }
                    }
                    return false;
                    
                case 'r':
                    if (rowDiff === 0 || colDiff === 0) {
                        return isPathClear(fromRow, fromCol, toRow, toCol);
                    }
                    return false;
                    
                case 'n':
                    return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
                    
                case 'b':
                    if (rowDiff === colDiff) {
                        return isPathClear(fromRow, fromCol, toRow, toCol);
                    }
                    return false;
                    
                case 'q':
                    if (rowDiff === 0 || colDiff === 0 || rowDiff === colDiff) {
                        return isPathClear(fromRow, fromCol, toRow, toCol);
                    }
                    return false;
                    
                case 'k':
                    if (rowDiff <= 1 && colDiff <= 1) return true;
                    
                    if (rowDiff === 0 && colDiff === 2) {
                        const isWhite = isPieceColor(gameBoard[fromRow][fromCol], 'white');
                        const kingRow = isWhite ? 7 : 0;
                        
                        if (fromRow !== kingRow) return false;
                        
                        if (toCol === 6) {
                            if (isWhite && !castlingRights.whiteKing) return false;
                            if (!isWhite && !castlingRights.blackKing) return false;
                            
                            if (gameBoard[kingRow][7] === (isWhite ? 'R' : 'r') && 
                                isPathClear(fromRow, fromCol, fromRow, 7)) {
                                return true;
                            }
                        }
                        
                        if (toCol === 2) {
                            if (isWhite && !castlingRights.whiteQueenside) return false;
                            if (!isWhite && !castlingRights.blackQueenside) return false;
                            
                            if (gameBoard[kingRow][0] === (isWhite ? 'R' : 'r') && 
                                isPathClear(fromRow, fromCol, fromRow, 0)) {
                                return true;
                            }
                        }
                    }
                    return false;
                    
                default:
                    return false;
            }
        }

        function getLegalMoves(color) {
            const legalMoves = [];
            
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = gameBoard[fromRow][fromCol];
                    if (piece && isPieceColor(piece, color)) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    const originalPiece = gameBoard[toRow][toCol];
                                    gameBoard[toRow][toCol] = piece;
                                    gameBoard[fromRow][fromCol] = '';
                                    
                                    const wouldBeInCheck = isInCheck(color);
                                    
                                    gameBoard[fromRow][fromCol] = piece;
                                    gameBoard[toRow][toCol] = originalPiece;
                                    
                                    if (!wouldBeInCheck) {
                                        legalMoves.push({ fromRow, fromCol, toRow, toCol });
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            return legalMoves;
        }

        function highlightKingInCheck() {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const square = document.getElementById(`square-${r}-${c}`);
                    if (square) {
                        square.classList.remove('king-in-check');
                    }
                }
            }
            
            if (isInCheck(currentTurn)) {
                const kingSymbol = currentTurn === 'white' ? 'K' : 'k';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (gameBoard[r][c] === kingSymbol) {
                            const square = document.getElementById(`square-${r}-${c}`);
                            if (square) {
                                square.classList.add('king-in-check');
                            }
                            break;
                        }
                    }
                }
            }
        }

        function updateNotations() {
            const notationsBox = document.getElementById('notationsBox');
            notationsBox.innerHTML = moveHistory.map((move, index) => {
                const moveNumber = Math.floor(index / 2) + 1;
                const isWhiteMove = index % 2 === 0;
                return isWhiteMove ? `${moveNumber}. ${move}` : ` ${move}`;
            }).join(' ');
            notationsBox.scrollTop = notationsBox.scrollHeight;
        }

        function resetPuzzle() {
            const puzzle = puzzles.find(p => p.id === currentPuzzleId);
            if (puzzle) {
             gameBoard = puzzle.board ? JSON.parse(JSON.stringify(puzzle.board)) : [];
                moveHistory = [];
                currentTurn = puzzle.firstMove || 'white';
                gameEnded = false;
                
                castlingRights = { whiteKing: true, whiteQueenside: true, blackKing: true, blackQueenside: true };
                enPassantTarget = null;
                
                initializeSolveBoard();
                document.getElementById('notationsBox').innerHTML = '';
                highlightKingInCheck();
            }
        }

        function checkSolutionMatch(userMoves, storedSolutions) {
            if (!storedSolutions || storedSolutions.length === 0) {
                return true;
            }
            
            const userMovesStr = userMoves.join(' ');
            for (const solution of storedSolutions) {
                if (userMovesStr === solution.join(' ')) {
                    return true;
                }
            }
            return false;
        }

        function hasUserSubmitted(puzzleId, userId) {
            if (!results[puzzleId]) return false;
            
            return results[puzzleId].some(result => result.userId === userId);
        }

        async function submitSolution() {
            if (!currentPuzzleId || moveHistory.length === 0) {
                alert('Please make some moves before submitting');
                return;
            }

            if (hasUserSubmitted(currentPuzzleId, currentUser.uid)) {
                alert('You have already submitted a solution for this puzzle.');
                return;
            }

            const puzzle = puzzles.find(p => p.id === currentPuzzleId);
            if (!puzzle) return;

            const elapsedTime = getElapsedTime();
            stopPuzzleTimer();

            const storedSolutions = solutions[currentPuzzleId] || [];
            const isCorrect = puzzle.hasSolutions ? checkSolutionMatch(moveHistory, storedSolutions) : true;

            const solution = {
                userId: currentUser.uid,
                playerName: currentUser.displayName,
                moves: [...moveHistory],
                submittedAt: new Date().toISOString(),
                moveCount: moveHistory.length,
                timeSpent: elapsedTime,
                isCorrect: isCorrect
            };

            const submitButton = event.target;
            const originalText = submitButton.textContent;
            submitButton.textContent = 'Submitting...';
            submitButton.disabled = true;

            try {
                await saveResultToFirestore(currentPuzzleId, solution);
                
                closeSolveModal();
                
                showSubmissionResultsModal(currentPuzzleId, solution);

            } catch (error) {
            } finally {
                submitButton.textContent = originalText;
                submitButton.disabled = false;
            }
        }

        function showSubmissionResultsModal(puzzleId, lastSubmission) {
            const resultsContent = document.getElementById('submissionResultsContent');
            resultsContent.innerHTML = '';
            
            const puzzleTitle = puzzles.find(p => p.id === puzzleId)?.title || "Puzzle Results";

            const allSubmissions = results[puzzleId] || [];
            const correctSubmissions = allSubmissions.filter(r => r.isCorrect).sort((a, b) => a.timeSpent - b.timeSpent);
            
            let userRank = 'N/A';
            let userResultClass = 'text-red-500';
            let userResultText = '✗ Incorrect';

            if (lastSubmission.isCorrect) {
                userResultClass = 'text-green-500';
                userResultText = '✓ Correct';
                const rankIndex = correctSubmissions.findIndex(sub => sub.userId === lastSubmission.userId);
                if (rankIndex !== -1) {
                    userRank = rankIndex + 1;
                }
            }

            const submissionHeader = document.createElement('h4');
            submissionHeader.className = 'text-xl font-bold mb-4';
            submissionHeader.textContent = `Results for "${puzzleTitle}"`;
            resultsContent.appendChild(submissionHeader);

            const userSubmissionCard = document.createElement('div');
            userSubmissionCard.className = 'bg-white p-4 rounded-lg shadow-md border-l-4 border-blue-500';
            userSubmissionCard.innerHTML = `
                <h5 class="font-bold text-lg text-gray-800">Your Submission</h5>
                <p class="text-gray-600">Name: <span class="font-semibold">${lastSubmission.playerName}</span></p>
                <p class="text-gray-600">Result: <span class="font-semibold ${userResultClass}">${userResultText}</span></p>
                <p class="text-gray-600">Time: <span class="font-semibold">${formatTime(lastSubmission.timeSpent)}</span></p>
                <p class="text-gray-600">Your Rank: <span class="font-semibold">${userRank}</span></p>
            `;
            resultsContent.appendChild(userSubmissionCard);

            if (correctSubmissions.length > 0) {
                const rankingListHeader = document.createElement('h5');
                rankingListHeader.className = 'font-bold text-lg mt-6 mb-2';
                rankingListHeader.textContent = 'Top Submissions';
                resultsContent.appendChild(rankingListHeader);
                
                const rankingList = document.createElement('div');
                rankingList.className = 'space-y-2';

                correctSubmissions.forEach((result, index) => {
                    if (index >= 5) return;
                    
                    const rankColor = index === 0 ? 'border-yellow-400 bg-yellow-50' : 
                                     index === 1 ? 'border-gray-400 bg-gray-50' : 
                                     index === 2 ? 'border-orange-400 bg-orange-50' : 'border-gray-300';
                    
                    const rankIcon = index === 0 ? '🥇' : 
                                    index === 1 ? '🥈' : 
                                    index === 2 ? '🥉' : `#${index + 1}`;

                    const rankCard = document.createElement('div');
                    rankCard.className = `border-l-4 ${rankColor} pl-4 py-2 rounded`;
                    rankCard.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div class="flex items-center space-x-2">
                                <span class="text-lg">${rankIcon}</span>
                                <span class="font-semibold text-gray-800">${result.playerName}</span>
                            </div>
                            <span class="text-sm text-gray-600">Time: ${formatTime(result.timeSpent)}</span>
                        </div>
                    `;
                    rankingList.appendChild(rankCard);
                });
                resultsContent.appendChild(rankingList);
            }

            document.getElementById('submissionResultsModal').classList.remove('hidden');
        }

        function closeSubmissionResultsModal() {
            document.getElementById('submissionResultsModal').classList.add('hidden');
        }

        function closeSolveModal() {
            document.getElementById('solveModal').classList.add('hidden');
            stopPuzzleTimer();
            clearSelection();
        }

        function closeSuccessModal() {
            document.getElementById('successModal').classList.add('hidden');
        }

        function verifyPassword() {
            const enteredPassword = document.getElementById('adminPassword').value;
            const targetSection = document.getElementById('passwordModal').getAttribute('data-target-section');
            const deletePuzzleId = document.getElementById('passwordModal').getAttribute('data-delete-puzzle-id');
            
            if (enteredPassword === adminPassword) {
                if (targetSection === 'create') {
                    isCreateAuthorized = true;
                } else if (targetSection === 'results') {
                    isResultsAuthorized = true;
                }
                
                document.getElementById('passwordModal').classList.add('hidden');
                document.getElementById('adminPassword').value = '';
                document.getElementById('passwordError').classList.add('hidden');
                
                if (targetSection === 'delete-confirm' && deletePuzzleId) {
                    confirmPuzzleDeletion(deletePuzzleId);
                    document.getElementById('passwordModal').removeAttribute('data-delete-puzzle-id');
                } else {
                    showSection(targetSection);
                }
            } else {
                document.getElementById('passwordError').classList.remove('hidden');
                document.getElementById('adminPassword').value = '';
            }
        }

        function closePasswordModal() {
            document.getElementById('passwordModal').classList.add('hidden');
            document.getElementById('adminPassword').value = '';
            document.getElementById('passwordError').classList.add('hidden');
        }

        function togglePasswordVisibility() {
            const passwordInput = document.getElementById('adminPassword');
            const eyeIcon = document.getElementById('eyeIcon');
            const eyeOffIcon = document.getElementById('eyeOffIcon');
            
            if (passwordInput.type === 'password') {
                passwordInput.type = 'text';
                eyeIcon.classList.add('hidden');
                eyeOffIcon.classList.remove('hidden');
            } else {
                passwordInput.type = 'password';
                eyeIcon.classList.remove('hidden');
                eyeOffIcon.classList.add('hidden');
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('adminPassword').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    verifyPassword();
                }
            });
        });

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        function displayResults() {
            const resultsList = document.getElementById('resultsList');
            resultsList.innerHTML = '';

            if (Object.keys(results).length === 0) {
                resultsList.innerHTML = '<div class="text-center text-gray-500 py-8">No results available yet.</div>';
                return;
            }

            const puzzleIdsWithResults = Object.keys(results).filter(puzzleId => {
                const puzzle = puzzles.find(p => p.id == puzzleId);
                return puzzle;
            });

            puzzleIdsWithResults.sort((a, b) => {
                const puzzleA = puzzles.find(p => p.id == a);
                const puzzleB = puzzles.find(p => p.id == b);
                if (!puzzleA || !puzzleB) return 0;
                return new Date(puzzleB.createdAt) - new Date(puzzleA.createdAt);
            });

            puzzleIdsWithResults.forEach(puzzleId => {
                const puzzle = puzzles.find(p => p.id == puzzleId);
                if (!puzzle) return;

                const puzzleResults = results[puzzleId];
                
                const resultCard = document.createElement('div');
                resultCard.className = 'bg-white rounded-lg shadow-lg mb-4';
                
                const header = document.createElement('div');
                header.className = 'p-6 cursor-pointer hover:bg-gray-50 transition-colors duration-200';
                header.onclick = () => toggleResultsSection(puzzleId);
                
                header.innerHTML = `
                    <div class="flex justify-between items-center">
                        <div>
                            <h3 class="text-xl font-bold text-gray-800 mb-2">${puzzle.title}</h3>
                            <div class="flex items-center space-x-4">
                                <span class="inline-block px-3 py-1 text-sm font-semibold ${puzzle.hasSolutions ? 'text-green-600 bg-green-100' : 'text-blue-600 bg-blue-100'} rounded-full">
                                    ${puzzle.hasSolutions ? 'With Solution Validation' : 'Open Solution'}
                                </span>
                                <span class="text-sm text-gray-500">${puzzleResults.length} submission${puzzleResults.length !== 1 ? 's' : ''}</span>
                            </div>
                        </div>
                        <div class="flex items-center">
                            <span class="text-sm text-gray-500 mr-2">Click to view results</span>
                            <svg id="arrow-${puzzleId}" class="w-5 h-5 text-gray-400 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                        </div>
                    </div>
                `;
                
                const content = document.createElement('div');
                content.id = `results-${puzzleId}`;
                content.className = 'hidden border-t border-gray-200 p-6 space-y-3';
                
                const correctSolutions = puzzleResults.filter(r => r.isCorrect).sort((a, b) => a.timeSpent - b.timeSpent);
                const incorrectSolutions = puzzleResults.filter(r => !r.isCorrect);
                
                let contentHtml = '';
                
                if (puzzleResults.length === 0) {
                    contentHtml = '<div class="text-gray-500">No submissions for this puzzle yet.</div>'
                } else {
                    if (correctSolutions.length > 0) {
                        contentHtml += '<h4 class="font-semibold text-gray-800 mb-3">Correct Solutions (Ranked by Time)</h4>';
                        correctSolutions.forEach((result, index) => {
                            const rankColor = index === 0 ? 'border-yellow-400 bg-yellow-50' : 
                                             index === 1 ? 'border-gray-400 bg-gray-50' : 
                                             index === 2 ? 'border-orange-400 bg-orange-50' : 'border-gray-300';
                            
                            const rankIcon = index === 0 ? '🥇' : 
                                            index === 1 ? '🥈' : 
                                            index === 2 ? '🥉' : `#${index + 1}`;

                            contentHtml += `
                                <div class="border-l-4 ${rankColor} pl-4 py-2">
                                    <div class="flex justify-between items-center">
                                        <div class="flex items-center space-x-2">
                                            <span class="text-lg">${rankIcon}</span>
                                            <span class="font-semibold text-gray-800">${result.playerName}</span>
                                            <span class="text-green-600 text-sm">✓ Correct</span>
                                        </div>
                                        <span class="text-sm text-gray-500">${new Date(result.submittedAt).toLocaleString()}</span>
                                    </div>
                                    <div class="text-sm text-gray-600 mt-1">
                                        Time: ${formatTime(result.timeSpent || 0)} | Moves: ${result.moveCount} | Solution: ${result.moves.join(' ')}
                                    </div>
                                </div>
                            `;
                        });
                    }
                    
                    if (incorrectSolutions.length > 0) {
                        if (correctSolutions.length > 0) {
                            contentHtml += '<div class="mt-6"></div>';
                        }
                        contentHtml += '<h4 class="font-semibold text-gray-800 mb-3">Other Submissions (Not ranked)</h4>';
                        incorrectSolutions.forEach(result => {
                            contentHtml += `
                                <div class="border-l-4 border-red-400 bg-red-50 pl-4 py-2">
                                    <div class="flex justify-between items-center">
                                        <div class="flex items-center space-x-2">
                                            <span class="text-lg"></span>
                                            <span class="font-semibold text-gray-800">${result.playerName}</span>
                                            <span class="text-red-600 text-sm">✗ Incorrect</span>
                                        </div>
                                        <span class="text-sm text-gray-500">${new Date(result.submittedAt).toLocaleString()}</span>
                                    </div>
                                    <div class="text-sm text-gray-600 mt-1">
                                        Time: ${formatTime(result.timeSpent || 0)} | Moves: ${result.moveCount} | Solution: ${result.moves.join(' ')}
                                    </div>
                                </div>
                            `;
                        });
                    }
                }
                
                content.innerHTML = contentHtml;
                
                resultCard.appendChild(header);
                resultCard.appendChild(content);
                resultsList.appendChild(resultCard);
            });
        }

        function toggleResultsSection(puzzleId) {
            const content = document.getElementById(`results-${puzzleId}`);
            const arrow = document.getElementById(`arrow-${puzzleId}`);
            
            if (content.classList.contains('hidden')) {
                content.classList.remove('hidden');
                arrow.classList.add('rotate-180');
            } else {
                content.classList.add('hidden');
                arrow.classList.remove('rotate-180');
            }
        }
    </script>
</body>
</html>
